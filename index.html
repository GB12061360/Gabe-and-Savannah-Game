<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Team Bear Â· Studio Edition</title>
    <meta name="theme-color" content="#0f172a" />
    <link rel="manifest" href="manifest.json" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script defer src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    <style>
      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at 20% 20%, #1f2937, #020617 65%);
        color: #e2e8f0;
        font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      }
      .glass {
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.92), rgba(30, 41, 59, 0.75));
        border: 1px solid rgba(148, 163, 184, 0.18);
        box-shadow: 0 24px 80px rgba(2, 6, 23, 0.65);
      }
      .soft-scroll::-webkit-scrollbar {
        width: 10px;
      }
      .soft-scroll::-webkit-scrollbar-thumb {
        background-color: rgba(148, 163, 184, 0.35);
        border-radius: 9999px;
      }
      .card-shimmer {
        position: relative;
        overflow: hidden;
      }
      .card-shimmer::after {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 60%;
        height: 100%;
        background: linear-gradient(110deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.35), rgba(255, 255, 255, 0));
        animation: sheen 2.6s ease-in-out infinite;
      }
      @keyframes sheen {
        0% {
          transform: translateX(0);
        }
        100% {
          transform: translateX(260%);
        }
      }
      .toast-enter {
        animation: toast-in 0.4s ease forwards;
      }
      @keyframes toast-in {
        0% {
          opacity: 0;
          transform: translateY(10px) scale(0.95);
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }
      .mini-game-overlay canvas {
        box-shadow: 0 16px 50px rgba(15, 23, 42, 0.5);
        border-radius: 26px;
      }
    </style>
  </head>
  <body class="min-h-screen">
    <div id="root" class="min-h-screen"></div>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useRef } = React;

      // === Balance constants (tune freely) ===
      const CONFIG = {
        STORAGE_KEY: "team_bear_v3",
        GRID: { COLS: 8, ROWS: 5, TILE: 96 },
        ROOM_PADDING: 32,
        BEAR_SPEED_TPS: 0.25,
        BEAR_IDLE_WINDOW_MS: [4200, 7800],
        BEAR_SLEEP_WINDOW_MS: [9000, 15000],
        FRAME_RATES: { idle: 9, walk: 10, sit: 8, sleep: 8, stretch: 9 },
        STAT_DECAY_IDLE_PER_MIN: -0.1,
        STAT_DECAY_CONTRACT_PER_MIN: -0.2,
        STAT_DECAY_THRESHOLD: 90,
        STAT_DECAY_REDUCTION_FACTOR: 0.5,
        QUICK_CARE_COST: 40,
        QUICK_CARE_BOOST: 10,
        BASE_STAT_MAX: 100,
        STAT_MIN: 0,
        CONTRACTS: [
          {
            id: "brief",
            label: "30m Precision Brief",
            durationMinutes: 30,
            energyCost: 16,
            payout: 320,
          },
          {
            id: "audit",
            label: "2h Compliance Audit",
            durationMinutes: 120,
            energyCost: 34,
            payout: 820,
          },
          {
            id: "overnight",
            label: "8h Overnight Vigil",
            durationMinutes: 480,
            energyCost: 55,
            payout: 2200,
          },
        ],
        RARITIES: {
          Common: { multiplier: 1.0, tone: "text-slate-300", border: "border-slate-500" },
          Rare: { multiplier: 1.2, tone: "text-sky-200", border: "border-sky-400" },
          Epic: { multiplier: 1.5, tone: "text-violet-200", border: "border-violet-400" },
          Legendary: { multiplier: 1.8, tone: "text-amber-200", border: "border-amber-400" },
        },
        DECOR_CATALOG: [
          { id: "lamp", name: "Carbon Wall Lamp", moraleCap: 2, note: "+2 morale cap", tint: "#facc15", value: 150 },
          { id: "fern", name: "Shadow Fern", moraleCap: 3, note: "+3 morale cap", tint: "#34d399", value: 180 },
          { id: "turntable", name: "Analog Turntable", moraleCap: 4, note: "+4 morale cap", tint: "#38bdf8", value: 240 },
          { id: "espresso", name: "Espresso Cart", moraleCap: 5, note: "+5 morale cap", tint: "#fb923c", value: 280 },
        ],
        ACCESSORY_LIBRARY: [
          { id: "felt-fedora", name: "Felt Fedora", slot: "head", rarity: "Rare", color: "#facc15" },
          { id: "sable-cape", name: "Sable Cape", slot: "body", rarity: "Epic", color: "#4c1d95" },
          { id: "river-stone", name: "River Stone Pendant", slot: "neck", rarity: "Common", color: "#38bdf8" },
          { id: "artisan-wrap", name: "Artisan Wrap", slot: "paws", rarity: "Rare", color: "#fb7185" },
          { id: "steel-monocle", name: "Steel Monocle", slot: "head", rarity: "Legendary", color: "#fcd34d" },
          { id: "umber-coat", name: "Umber Coat", slot: "colorway", rarity: "Epic", color: "#78350f" },
          { id: "midnight-band", name: "Midnight Band", slot: "neck", rarity: "Epic", color: "#0ea5e9" },
        ],
        PACK_TYPES: {
          standard: {
            name: "Standard Pack",
            draws: 3,
            price: 180,
            rarityWeights: { Common: 55, Rare: 30, Epic: 12, Legendary: 3 },
            guaranteedAccessory: false,
          },
          elite: {
            name: "Elite Pack",
            draws: 4,
            price: 420,
            rarityWeights: { Common: 40, Rare: 34, Epic: 20, Legendary: 6 },
            guaranteedAccessory: true,
          },
          premier: {
            name: "Premier Pack",
            draws: 5,
            price: 760,
            rarityWeights: { Common: 28, Rare: 36, Epic: 26, Legendary: 10 },
            guaranteedAccessory: true,
          },
        },
        MILESTONES: [
          {
            id: "professional-i",
            name: "Professional I",
            description: "Maintain every stat above 70 for three cumulative hours.",
            reward: { credits: 240 },
          },
          {
            id: "craftsman",
            name: "Craftsman",
            description: "Complete five contracts without morale dipping under 50.",
            reward: { pack: "standard" },
          },
          {
            id: "steady-hand",
            name: "Steady Hand",
            description: "Earn 10,000 lifetime credits.",
            reward: { credits: 600 },
          },
        ],
        MINI_GAME_LIMITS: { perHour: 2, perDay: 5, durationSeconds: 75 },
        MINI_GAMES: [
          {
            id: "timberline",
            name: "Timberline Rhythm",
            description: "Tap on beat for streak multipliers.",
            minReward: 60,
            maxReward: 180,
          },
          {
            id: "riverside",
            name: "Riverside Fishing",
            description: "Ride the timing bar to reel better catches.",
            minReward: 30,
            maxReward: 200,
          },
          {
            id: "courier",
            name: "Courier Run",
            description: "Swap lanes and stay composed over distance.",
            minReward: 45,
            maxReward: 200,
          },
          { id: "memory", name: "Memory Rack", description: "Under construction.", disabled: true },
          { id: "workshop", name: "Workshop", description: "Under construction.", disabled: true },
        ],
        KJV_VERSES: [
          { ref: "Psalm 90:17", text: "And let the beauty of the LORD our God be upon us: and establish thou the work of our hands upon us." },
          { ref: "Proverbs 22:29", text: "Seest thou a man diligent in his business? he shall stand before kings; he shall not stand before mean men." },
          { ref: "Colossians 3:23", text: "And whatsoever ye do, do it heartily, as to the Lord, and not unto men." },
        ],
        FIREBASE_COLLECTION: "team_bear_profile_v3",
      };

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
      const lerp = (a, b, t) => a + (b - a) * t;
      const randomRange = (min, max) => Math.random() * (max - min) + min;
      const now = () => Date.now();

      const weightedPick = (weights) => {
        const total = Object.values(weights).reduce((sum, val) => sum + val, 0);
        let threshold = Math.random() * total;
        for (const key of Object.keys(weights)) {
          threshold -= weights[key];
          if (threshold <= 0) return key;
        }
        return Object.keys(weights)[0];
      };

      const baseGameState = () => ({
        credits: 720,
        vouchers: 0,
        rarity: "Epic",
        stats: { energy: 88, cleanliness: 82, morale: 90 },
        decor: [],
        accessories: {
          inventory: CONFIG.ACCESSORY_LIBRARY.map((item) => ({ ...item, quantity: item.rarity === "Common" ? 1 : 0 })),
          equipped: { head: null, neck: null, body: null, paws: null, colorway: null },
        },
        packs: { standard: 1, elite: 0, premier: 0 },
        milestones: CONFIG.MILESTONES.map((m) => ({ id: m.id, progress: 0, achieved: false, claimed: false })),
        settings: { showKJV: false, volume: 0.4 },
        contract: null,
        lastTick: now(),
        lifetime: { creditsEarned: 0, dutyMinutes: 0, contractsCompleted: 0, moraleAbove70Minutes: 0 },
        miniGameUsage: {},
        verseIndex: 0,
        toast: [],
      });

      const moraleMax = (decor) => CONFIG.BASE_STAT_MAX + decor.reduce((acc, item) => acc + (item.moraleCap || 0), 0);

      class SpriteAnimator {
        constructor() {
          this.state = "idle";
          this.frames = this.createFrames();
          this.frameIndex = 0;
          this.accumulator = 0;
          this.fps = CONFIG.FRAME_RATES.idle;
        }

        createFrames() {
          const frame = (pose) => (ctx, flipped, accessories) => {
            ctx.save();
            if (flipped) {
              ctx.scale(-1, 1);
            }
            const colorway = accessories?.colorway?.color || "#3f2f27";
            ctx.fillStyle = colorway;
            // body
            ctx.beginPath();
            ctx.ellipse(0, -20, 28, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            // belly
            ctx.fillStyle = "#604437";
            ctx.beginPath();
            ctx.ellipse(0, -10, 14, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            // head
            ctx.fillStyle = colorway;
            ctx.beginPath();
            ctx.ellipse(0, -54 + pose.headOffset, 22 + pose.headStretch, 18 + pose.headStretch, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#f1e4d0";
            ctx.beginPath();
            ctx.ellipse(0, -52 + pose.headOffset, 12 + pose.headStretch * 0.6, 9 + pose.headStretch * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            // ears
            ctx.fillStyle = colorway;
            ctx.beginPath();
            ctx.ellipse(-16, -70 + pose.headOffset, 6, 6, 0, 0, Math.PI * 2);
            ctx.ellipse(16, -70 + pose.headOffset, 6, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            // eyes
            ctx.fillStyle = "#020617";
            ctx.beginPath();
            ctx.arc(-6 + pose.eyeOffset, -58 + pose.headOffset, 2, 0, Math.PI * 2);
            ctx.arc(6 + pose.eyeOffset, -58 + pose.headOffset, 2, 0, Math.PI * 2);
            ctx.fill();
            // paws
            ctx.fillStyle = colorway;
            ctx.beginPath();
            ctx.ellipse(-16 + pose.leftPaw.x, -4 + pose.leftPaw.y, 10, 14, 0.2, 0, Math.PI * 2);
            ctx.ellipse(16 + pose.rightPaw.x, -4 + pose.rightPaw.y, 10, 14, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-12, 10 + pose.footOffset, 10, 14, 0, 0, Math.PI * 2);
            ctx.ellipse(12, 10 + pose.footOffset, 10, 14, 0, 0, Math.PI * 2);
            ctx.fill();
            this.drawAccessories(ctx, accessories, pose);
            ctx.restore();
          };

          const states = {
            idle: [
              { headOffset: 0, headStretch: 0, eyeOffset: 0, leftPaw: { x: -2, y: 2 }, rightPaw: { x: 2, y: -1 }, footOffset: 0 },
              { headOffset: -1, headStretch: 0.4, eyeOffset: 0.4, leftPaw: { x: -1, y: 1 }, rightPaw: { x: 1, y: 0 }, footOffset: 0.4 },
              { headOffset: 0, headStretch: 0, eyeOffset: -0.2, leftPaw: { x: -3, y: 2 }, rightPaw: { x: 3, y: -1 }, footOffset: 0 },
            ],
            walk: [
              { headOffset: 0, headStretch: 0, eyeOffset: 0, leftPaw: { x: -6, y: -4 }, rightPaw: { x: 4, y: 6 }, footOffset: 0 },
              { headOffset: -1, headStretch: 0.2, eyeOffset: 0, leftPaw: { x: -4, y: -2 }, rightPaw: { x: 6, y: 4 }, footOffset: 0 },
              { headOffset: 0, headStretch: 0, eyeOffset: 0, leftPaw: { x: 4, y: 6 }, rightPaw: { x: -6, y: -4 }, footOffset: 0 },
              { headOffset: -1, headStretch: 0.2, eyeOffset: 0, leftPaw: { x: 6, y: 4 }, rightPaw: { x: -4, y: -2 }, footOffset: 0 },
            ],
            sit: [
              { headOffset: 3, headStretch: -0.6, eyeOffset: 0.2, leftPaw: { x: -12, y: 12 }, rightPaw: { x: 12, y: 12 }, footOffset: 4 },
              { headOffset: 4, headStretch: -0.8, eyeOffset: 0.4, leftPaw: { x: -11, y: 12 }, rightPaw: { x: 11, y: 12 }, footOffset: 4 },
            ],
            sleep: [
              { headOffset: 8, headStretch: 1.2, eyeOffset: -2, leftPaw: { x: -10, y: 14 }, rightPaw: { x: 10, y: 14 }, footOffset: 6 },
              { headOffset: 9, headStretch: 1.4, eyeOffset: -2, leftPaw: { x: -11, y: 14 }, rightPaw: { x: 11, y: 14 }, footOffset: 6 },
            ],
            stretch: [
              { headOffset: -6, headStretch: 0.6, eyeOffset: 0.2, leftPaw: { x: -8, y: -12 }, rightPaw: { x: 8, y: -12 }, footOffset: -4 },
              { headOffset: -5, headStretch: 0.4, eyeOffset: 0.2, leftPaw: { x: -6, y: -10 }, rightPaw: { x: 6, y: -10 }, footOffset: -2 },
              { headOffset: -6, headStretch: 0.6, eyeOffset: 0.2, leftPaw: { x: -8, y: -12 }, rightPaw: { x: 8, y: -12 }, footOffset: -4 },
            ],
          };

          Object.keys(states).forEach((state) => {
            states[state] = states[state].map((pose) => ({ draw: frame(pose) }));
          });
          return states;
        }

        drawAccessories(ctx, accessories, pose) {
          if (!accessories) return;
          if (accessories.head) {
            ctx.save();
            ctx.translate(0, -72 + pose.headOffset);
            ctx.fillStyle = accessories.head.color;
            ctx.fillRect(-18, -6, 36, 8);
            ctx.fillRect(-14, -12, 28, 6);
            ctx.restore();
          }
          if (accessories.neck) {
            ctx.save();
            ctx.translate(0, -40 + pose.headOffset);
            ctx.strokeStyle = accessories.neck.color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, 14, Math.PI * 0.8, Math.PI * 0.2);
            ctx.stroke();
            ctx.restore();
          }
          if (accessories.body) {
            ctx.save();
            ctx.translate(0, -22);
            ctx.fillStyle = accessories.body.color;
            ctx.globalAlpha = 0.45;
            ctx.fillRect(-24, -14, 48, 36);
            ctx.restore();
          }
          if (accessories.paws) {
            ctx.save();
            ctx.translate(0, 4 + pose.footOffset);
            ctx.fillStyle = accessories.paws.color;
            ctx.globalAlpha = 0.65;
            ctx.beginPath();
            ctx.ellipse(-12, 6, 12, 8, 0, 0, Math.PI * 2);
            ctx.ellipse(12, 6, 12, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        setState(state) {
          if (state === this.state) return;
          this.state = state;
          this.fps = CONFIG.FRAME_RATES[state] || 8;
          this.frameIndex = 0;
          this.accumulator = 0;
        }

        update(dt) {
          const frames = this.frames[this.state];
          if (!frames || frames.length === 0) return;
          const frameDuration = 1000 / this.fps;
          this.accumulator += dt;
          while (this.accumulator >= frameDuration) {
            this.accumulator -= frameDuration;
            this.frameIndex = (this.frameIndex + 1) % frames.length;
          }
        }

        draw(ctx, accessories, flipped) {
          const frames = this.frames[this.state];
          const current = frames[this.frameIndex] || frames[0];
          ctx.save();
          current.draw(ctx, flipped, accessories);
          ctx.restore();
        }
      }
      class BearController {
        constructor(room) {
          this.room = room;
          this.animator = new SpriteAnimator();
          this.gridPosition = { col: 3, row: 2 };
          this.target = { ...this.gridPosition };
          this.pixel = this.room.tileToPoint(this.gridPosition);
          this.facing = 1;
          this.behavior = "idle";
          this.stateTimer = randomRange(...CONFIG.BEAR_IDLE_WINDOW_MS);
          this.sleepUntil = null;
          this.accessories = {};
        }

        setAccessories(accessories) {
          this.accessories = accessories;
        }

        pickNewTarget() {
          this.target = this.room.randomTile();
          this.behavior = "walk";
          this.animator.setState("walk");
        }

        update(dt) {
          if (this.sleepUntil && now() < this.sleepUntil) {
            this.animator.setState("sleep");
            this.animator.update(dt);
            return;
          }
          if (this.sleepUntil && now() >= this.sleepUntil) {
            this.sleepUntil = null;
            this.behavior = "idle";
            this.stateTimer = randomRange(...CONFIG.BEAR_IDLE_WINDOW_MS);
          }

          const targetPoint = this.room.tileToPoint(this.target);
          const dx = targetPoint.x - this.pixel.x;
          const dy = targetPoint.y - this.pixel.y;
          const distance = Math.hypot(dx, dy);
          const speed = CONFIG.GRID.TILE * CONFIG.BEAR_SPEED_TPS * (dt / 1000);

          if (distance > 1) {
            this.animator.setState("walk");
            this.facing = dx >= 0 ? 1 : -1;
            const ratio = Math.min(speed / distance, 1);
            const eased = easeInOutQuad(ratio);
            this.pixel.x += dx * eased;
            this.pixel.y += dy * eased;
          } else {
            this.gridPosition = { ...this.target };
            if (this.behavior === "walk") {
              this.behavior = "idle";
              this.stateTimer = randomRange(...CONFIG.BEAR_IDLE_WINDOW_MS);
            }
            this.animator.setState(this.behavior);
            this.stateTimer -= dt;
            if (this.stateTimer <= 0) {
              this.chooseBehavior();
            }
          }
          this.animator.update(dt);
        }

        chooseBehavior() {
          const sequence = ["stretch", "sit", "walk", "sleep", "idle"];
          const pick = sequence[Math.floor(Math.random() * sequence.length)];
          if (pick === "walk") {
            this.pickNewTarget();
          } else if (pick === "sleep") {
            this.behavior = "sleep";
            this.sleepUntil = now() + randomRange(...CONFIG.BEAR_SLEEP_WINDOW_MS);
          } else {
            this.behavior = pick;
            this.animator.setState(pick);
            this.stateTimer = randomRange(...CONFIG.BEAR_IDLE_WINDOW_MS);
          }
        }

        draw(ctx) {
          ctx.save();
          ctx.translate(this.pixel.x, this.pixel.y);
          this.animator.draw(ctx, this.accessories, this.facing < 0);
          ctx.restore();
        }
      }

      class EventBus {
        constructor() {
          this.listeners = {};
        }
        on(event, handler) {
          if (!this.listeners[event]) this.listeners[event] = [];
          this.listeners[event].push(handler);
        }
        off(event, handler) {
          this.listeners[event] = (this.listeners[event] || []).filter((fn) => fn !== handler);
        }
        emit(event, payload) {
          (this.listeners[event] || []).forEach((fn) => fn(payload));
        }
      }

      class RoomEngine {
        constructor(canvas, bus) {
          this.canvas = canvas;
          this.bus = bus;
          this.ctx = canvas.getContext("2d");
          this.decor = [];
          this.width = CONFIG.GRID.COLS * CONFIG.GRID.TILE;
          this.height = CONFIG.GRID.ROWS * CONFIG.GRID.TILE;
          this.canvas.width = this.width;
          this.canvas.height = this.height;
          this.bear = new BearController(this);
          this.pointer = { x: 0, y: 0 };
          this.lastTick = now();
          this.running = true;
          this.setupInteractions();
          this.loop();
        }

        setupInteractions() {
          this.canvas.addEventListener("pointermove", (event) => {
            const rect = this.canvas.getBoundingClientRect();
            this.pointer = { x: event.clientX - rect.left, y: event.clientY - rect.top };
            this.bus.emit("room-pointer", { ...this.pointer });
          });
          this.canvas.addEventListener("pointerleave", () => this.bus.emit("room-pointer-leave"));
          this.canvas.addEventListener("pointerup", (event) => {
            const rect = this.canvas.getBoundingClientRect();
            const point = { x: event.clientX - rect.left, y: event.clientY - rect.top };
            this.bus.emit("room-pointer-up", this.pointToTile(point));
          });
        }

        randomTile() {
          return {
            col: Math.floor(Math.random() * CONFIG.GRID.COLS),
            row: Math.floor(Math.random() * CONFIG.GRID.ROWS),
          };
        }

        setDecor(decor) {
          this.decor = decor;
        }

        setAccessories(accessories) {
          this.bear.setAccessories(accessories);
        }

        tileToPoint(tile) {
          return {
            x: tile.col * CONFIG.GRID.TILE + CONFIG.GRID.TILE / 2,
            y: tile.row * CONFIG.GRID.TILE + CONFIG.GRID.TILE * 0.85,
          };
        }

        pointToTile(point) {
          return {
            col: clamp(Math.floor(point.x / CONFIG.GRID.TILE), 0, CONFIG.GRID.COLS - 1),
            row: clamp(Math.floor(point.y / CONFIG.GRID.TILE), 0, CONFIG.GRID.ROWS - 1),
          };
        }

        drawFloor(ctx) {
          for (let row = 0; row < CONFIG.GRID.ROWS; row++) {
            for (let col = 0; col < CONFIG.GRID.COLS; col++) {
              const shade = (row + col) % 2 === 0 ? "rgba(30, 41, 59, 0.95)" : "rgba(15, 23, 42, 0.92)";
              ctx.fillStyle = shade;
              ctx.fillRect(col * CONFIG.GRID.TILE, row * CONFIG.GRID.TILE, CONFIG.GRID.TILE, CONFIG.GRID.TILE);
              ctx.strokeStyle = "rgba(148, 163, 184, 0.1)";
              ctx.strokeRect(col * CONFIG.GRID.TILE, row * CONFIG.GRID.TILE, CONFIG.GRID.TILE, CONFIG.GRID.TILE);
            }
          }
        }

        drawDecor(item) {
          const ctx = this.ctx;
          const pos = this.tileToPoint(item);
          ctx.save();
          ctx.translate(pos.x, pos.y);
          ctx.fillStyle = "rgba(15, 23, 42, 0.55)";
          ctx.fillRect(-18, CONFIG.GRID.TILE * 0.35, 36, 6);
          ctx.fillStyle = item.tint || "#38bdf8";
          ctx.beginPath();
          ctx.roundRect(-20, -40, 40, 52, 14);
          ctx.fill();
          ctx.restore();
        }

        loop() {
          if (!this.running) return;
          const time = now();
          const dt = time - this.lastTick;
          this.lastTick = time;
          this.update(dt);
          this.render();
          requestAnimationFrame(() => this.loop());
        }

        update(dt) {
          this.bear.update(dt);
        }

        render() {
          const ctx = this.ctx;
          ctx.clearRect(0, 0, this.width, this.height);
          this.drawFloor(ctx);
          const entities = [
            ...this.decor.map((item) => ({ type: "decor", item })),
            { type: "bear", item: this.bear },
          ];
          entities.sort((a, b) => {
            const ay = a.type === "bear" ? this.bear.pixel.y : this.tileToPoint(a.item).y;
            const by = b.type === "bear" ? this.bear.pixel.y : this.tileToPoint(b.item).y;
            return ay - by;
          });
          for (const entry of entities) {
            if (entry.type === "decor") {
              this.drawDecor(entry.item);
            } else {
              ctx.save();
              ctx.translate(this.bear.pixel.x, this.bear.pixel.y);
              this.bear.animator.draw(ctx, this.bear.accessories, this.bear.facing < 0);
              ctx.restore();
            }
          }
        }
      }
      const loadState = () => {
        try {
          const raw = localStorage.getItem(CONFIG.STORAGE_KEY);
          if (!raw) return baseGameState();
          const parsed = JSON.parse(raw);
          return { ...baseGameState(), ...parsed };
        } catch (error) {
          console.warn("Failed to read save", error);
          return baseGameState();
        }
      };

      const saveState = (state) => {
        localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(state));
      };

      const mirrorToFirebase = async (state) => {
        if (!window.BEAR_FIREBASE_CONFIG) return;
        if (!window.firebase) return;
        try {
          if (!window.firebase.apps.length) {
            window.firebase.initializeApp(window.BEAR_FIREBASE_CONFIG);
          }
          const firestore = window.firebase.firestore();
          await firestore.collection(CONFIG.FIREBASE_COLLECTION).doc("profile").set(state, { merge: true });
        } catch (error) {
          console.warn("Firebase mirror skipped", error);
        }
      };

      class PackEngine {
        constructor(stateRef, setState) {
          this.stateRef = stateRef;
          this.setState = setState;
        }

        openPack(key) {
          const pack = CONFIG.PACK_TYPES[key];
          if (!pack) return [];
          const state = this.stateRef.current;
          if (state.credits < pack.price) return [];
          state.credits -= pack.price;
          const results = [];
          const guaranteeIndex = pack.guaranteedAccessory ? Math.floor(Math.random() * pack.draws) : -1;
          for (let i = 0; i < pack.draws; i++) {
            const rarity = i === guaranteeIndex
              ? weightedPick({ Rare: 45, Epic: 35, Legendary: 20 })
              : weightedPick(pack.rarityWeights);
            const dropAccessory = pack.guaranteedAccessory && i === guaranteeIndex ? true : Math.random() < 0.35;
            if (dropAccessory) {
              const pool = CONFIG.ACCESSORY_LIBRARY.filter((acc) => acc.rarity === rarity);
              const accessory = pool[Math.floor(Math.random() * pool.length)] || CONFIG.ACCESSORY_LIBRARY[0];
              const inventory = state.accessories.inventory.find((item) => item.id === accessory.id);
              let duplicate = false;
              if (inventory) {
                if (inventory.quantity > 0) duplicate = true;
                inventory.quantity += 1;
              } else {
                state.accessories.inventory.push({ ...accessory, quantity: 1 });
              }
              if (duplicate) {
                const voucherGain = rarity === "Legendary" ? 12 : rarity === "Epic" ? 8 : rarity === "Rare" ? 5 : 2;
                state.vouchers += voucherGain;
                state.toast.push({ id: `voucher-${Date.now()}-${i}`, message: `Duplicate â Vouchers +${voucherGain}` });
              }
              results.push({ type: "accessory", rarity, accessory, duplicate });
            } else {
              const credits = Math.floor(lerp(40, 200, Math.random()));
              state.credits += credits;
              state.lifetime.creditsEarned += credits;
              results.push({ type: "credit", rarity, credits });
            }
          }
          this.setState({ ...state });
          return results;
        }
      }

      const defaultMiniGameState = () => ({
        active: false,
        id: null,
        startTime: null,
        score: 0,
        data: {},
        reward: 0,
      });
      const StatBar = ({ label, value, tone }) => (
        <div className="mb-4">
          <div className="mb-1 flex justify-between text-xs uppercase tracking-[0.3em] text-slate-400">
            <span>{label}</span>
            <span>{Math.round(value)}</span>
          </div>
          <div className="h-2.5 w-full overflow-hidden rounded-full bg-slate-800">
            <div className={`h-full ${tone}`} style={{ width: `${clamp(value, 0, 100)}%`, transition: "width 0.6s ease" }}></div>
          </div>
        </div>
      );

      const StatsPanel = ({ stats, decor, onQuickCare, canAfford }) => {
        const moraleCap = moraleMax(decor);
        return (
          <div className="glass rounded-3xl p-6">
            <div className="flex items-center justify-between">
              <h2 className="text-lg font-semibold text-slate-100">Vitals</h2>
              <button
                onClick={onQuickCare}
                disabled={!canAfford}
                className={`rounded-full px-4 py-2 text-xs font-semibold uppercase tracking-[0.3em] transition ${
                  canAfford ? "bg-emerald-500/90 text-emerald-50 hover:bg-emerald-400" : "bg-slate-700 text-slate-500"
                }`}
              >
                Quick Care Â· 40 Credits
              </button>
            </div>
            <div className="mt-4">
              <StatBar label="Energy" value={stats.energy} tone="bg-emerald-400" />
              <StatBar label="Cleanliness" value={stats.cleanliness} tone="bg-cyan-400" />
              <StatBar label={`Morale (cap ${moraleCap})`} value={(stats.morale / moraleCap) * 100} tone="bg-amber-400" />
            </div>
          </div>
        );
      };

      const CurrencyPanel = ({ credits, vouchers }) => (
        <div className="glass rounded-3xl p-6">
          <div className="flex items-center justify-between text-xs uppercase tracking-[0.3em] text-slate-500">
            <span>Ledger</span>
            <span>Reserves</span>
          </div>
          <div className="mt-4 space-y-3">
            <div className="flex items-center justify-between text-lg font-semibold text-slate-100">
              <span>Credits</span>
              <span>{Math.round(credits)}</span>
            </div>
            <div className="flex items-center justify-between text-lg font-semibold text-slate-100">
              <span>Vouchers</span>
              <span>{Math.round(vouchers)}</span>
            </div>
          </div>
        </div>
      );

      const ContractPanel = ({ contract, onStart, onCancel }) => (
        <div className="glass rounded-3xl p-6">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-slate-100">Contracts</h2>
            {contract && (
              <button onClick={onCancel} className="text-xs uppercase tracking-[0.3em] text-rose-300">
                Cancel
              </button>
            )}
          </div>
          <div className="mt-4 space-y-4">
            {CONFIG.CONTRACTS.map((job) => {
              const active = contract && contract.id === job.id;
              const remaining = active ? Math.max(0, contract.endsAt - now()) : 0;
              const minutes = Math.ceil(remaining / 60000);
              return (
                <div key={job.id} className={`rounded-2xl border border-slate-600/40 p-4 ${active ? "bg-slate-800/60" : "bg-slate-900/40"}`}>
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="text-sm font-semibold text-slate-100">{job.label}</div>
                      <div className="text-xs text-slate-400">Energy â{job.energyCost} Â· {job.durationMinutes}m</div>
                    </div>
                    <div className="text-sm font-semibold text-amber-300">+{job.payout} cr</div>
                  </div>
                  <div className="mt-2">
                    {active ? (
                      <div className="text-xs text-slate-400">{minutes} minutes remaining</div>
                    ) : (
                      <button
                        onClick={() => onStart(job)}
                        className="mt-2 rounded-full bg-slate-700 px-3 py-1 text-xs uppercase tracking-[0.3em] text-slate-200 hover:bg-slate-600"
                      >
                        Launch Contract
                      </button>
                    )}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );

      const DecorOverlay = ({ decor, onMove, onSell }) => (
        <div className="pointer-events-none absolute inset-0">
          {decor.map((item) => (
            <div
              key={item.uid}
              style={{ left: item.col * CONFIG.GRID.TILE, top: item.row * CONFIG.GRID.TILE, width: CONFIG.GRID.TILE, height: CONFIG.GRID.TILE }}
              className="pointer-events-auto absolute"
            >
              <div className="absolute inset-x-6 top-3 flex items-center justify-between rounded-full bg-slate-900/70 px-3 py-1 text-[10px] uppercase tracking-[0.3em] text-slate-300 opacity-0 transition hover:opacity-100">
                <button onPointerDown={(e) => { e.stopPropagation(); onMove(item); }} className="hover:text-emerald-200">
                  Move
                </button>
                <span className="mx-1 text-slate-500">â¢</span>
                <button onPointerDown={(e) => { e.stopPropagation(); onSell(item); }} className="hover:text-rose-300">
                  Sell
                </button>
              </div>
            </div>
          ))}
        </div>
      );
      const DecorCatalog = ({ onBeginDrag }) => (
        <div className="glass h-full rounded-3xl p-6">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-slate-100">Decor Catalog</h2>
            <span className="text-xs uppercase tracking-[0.3em] text-slate-500">Morale Caps</span>
          </div>
          <div className="mt-4 space-y-3">
            {CONFIG.DECOR_CATALOG.map((item) => (
              <button
                key={item.id}
                onPointerDown={(event) => {
                  event.preventDefault();
                  onBeginDrag({ ...item, uid: `decor-${item.id}-${Date.now()}`, isNew: true });
                }}
                className="flex w-full items-center justify-between rounded-2xl border border-slate-700/50 bg-slate-900/40 p-4 text-left transition hover:border-slate-500"
              >
                <div>
                  <div className="text-sm font-semibold text-slate-100">{item.name}</div>
                  <div className="text-xs text-slate-400">{item.note}</div>
                </div>
                <div className="text-sm font-semibold text-amber-300">{item.value} cr</div>
              </button>
            ))}
          </div>
        </div>
      );

      const PackButton = ({ pack, onOpen }) => (
        <button
          onClick={onOpen}
          className="relative flex flex-col rounded-3xl border border-slate-600/40 bg-slate-900/50 p-6 text-left transition hover:border-slate-400"
        >
          <span className="text-xs uppercase tracking-[0.4em] text-slate-500">{pack.name}</span>
          <span className="mt-2 text-2xl font-semibold text-slate-100">{pack.price} cr</span>
          <span className="mt-3 text-xs text-slate-400">{pack.draws} cards Â· {pack.guaranteedAccessory ? "Accessory guaranteed" : "Accessory chance"}</span>
        </button>
      );

      const PackReveal = ({ results, onClose }) => (
        <div className="fixed inset-0 z-40 flex items-center justify-center bg-slate-950/80 backdrop-blur-sm">
          <div className="glass pack-parallax relative w-full max-w-3xl rounded-3xl p-8">
            <div className="flex items-center justify-between">
              <h2 className="text-lg font-semibold text-slate-100">Pack Reveal</h2>
              <button onClick={onClose} className="text-xs uppercase tracking-[0.3em] text-slate-400">
                Close
              </button>
            </div>
            <div className="mt-8 flex flex-wrap justify-center gap-6">
              {results.map((drop, index) => (
                <div
                  key={index}
                  className={`card-shimmer relative h-48 w-32 overflow-hidden rounded-2xl border border-slate-500/40 ${
                    drop.rarity === "Legendary"
                      ? "rarity-legendary"
                      : drop.rarity === "Epic"
                      ? "rarity-epic"
                      : drop.rarity === "Rare"
                      ? "rarity-rare"
                      : "rarity-common"
                  }`}
                >
                  <div className="absolute inset-0 bg-gradient-to-br from-white/5 via-transparent to-white/5"></div>
                  <div className="absolute inset-0 flex flex-col items-center justify-center gap-2 text-center">
                    <span className="text-xs uppercase tracking-[0.4em] text-slate-300">{drop.rarity}</span>
                    {drop.type === "credit" ? (
                      <>
                        <span className="text-2xl font-semibold text-emerald-200">+{drop.credits}</span>
                        <span className="text-xs text-slate-400">Credits</span>
                      </>
                    ) : (
                      <>
                        <span className="text-sm font-semibold text-slate-100">{drop.accessory.name}</span>
                        <span className="text-xs text-slate-400">{drop.accessory.slot}</span>
                        {drop.duplicate && <span className="mt-1 text-[10px] uppercase tracking-[0.3em] text-amber-300">Converted to vouchers</span>}
                      </>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      );
      const AccessorySlot = ({ label, slot, equipped, inventory, onEquip }) => {
        const current = equipped[slot];
        return (
          <div className="rounded-2xl border border-slate-700/40 bg-slate-900/40 p-4">
            <div className="text-xs uppercase tracking-[0.3em] text-slate-500">{label}</div>
            <div className="mt-2 text-sm font-semibold text-slate-100">{current ? current.name : "None"}</div>
            <div className="mt-3 space-y-2">
              {inventory
                .filter((item) => item.slot === slot && item.quantity > 0)
                .map((item) => (
                  <button
                    key={item.id}
                    onClick={() => onEquip(slot, item)}
                    className={`flex w-full items-center justify-between rounded-full px-3 py-1 text-xs uppercase tracking-[0.3em] ${
                      current && current.id === item.id ? "bg-emerald-500/30 text-emerald-100" : "bg-slate-800 text-slate-300"
                    }`}
                  >
                    <span>{item.name}</span>
                    <span className="text-[10px] text-slate-400">{item.rarity}</span>
                  </button>
                ))}
            </div>
          </div>
        );
      };

      const WardrobeModal = ({ inventory, equipped, onClose, onEquip }) => (
        <div className="fixed inset-0 z-40 flex items-center justify-center bg-slate-950/80 backdrop-blur">
          <div className="glass relative w-full max-w-4xl rounded-3xl p-8">
            <div className="flex items-start justify-between">
              <div>
                <h2 className="text-lg font-semibold text-slate-100">Wardrobe</h2>
                <p className="text-xs text-slate-400">Tailor the bear's profile with understated accessories.</p>
              </div>
              <button onClick={onClose} className="text-xs uppercase tracking-[0.3em] text-slate-400">
                Close
              </button>
            </div>
            <div className="mt-6 grid grid-cols-2 gap-5">
              <AccessorySlot label="Head" slot="head" inventory={inventory} equipped={equipped} onEquip={onEquip} />
              <AccessorySlot label="Neck" slot="neck" inventory={inventory} equipped={equipped} onEquip={onEquip} />
              <AccessorySlot label="Body" slot="body" inventory={inventory} equipped={equipped} onEquip={onEquip} />
              <AccessorySlot label="Paws" slot="paws" inventory={inventory} equipped={equipped} onEquip={onEquip} />
              <AccessorySlot label="Colorway" slot="colorway" inventory={inventory} equipped={equipped} onEquip={onEquip} />
            </div>
          </div>
        </div>
      );

      const MilestonesPanel = ({ milestones, definitions, onClaim }) => (
        <div className="glass rounded-3xl p-6">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-semibold text-slate-100">Milestones</h2>
            <span className="text-xs uppercase tracking-[0.3em] text-slate-500">Progress</span>
          </div>
          <div className="mt-4 space-y-4">
            {definitions.map((definition) => {
              const record = milestones.find((entry) => entry.id === definition.id);
              const achieved = record?.achieved;
              const claimed = record?.claimed;
              return (
                <div key={definition.id} className="rounded-2xl border border-slate-600/40 bg-slate-900/40 p-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="text-sm font-semibold text-slate-100">{definition.name}</div>
                      <div className="text-xs text-slate-400">{definition.description}</div>
                    </div>
                    <div className="text-xs text-amber-300">
                      {definition.reward.credits ? `${definition.reward.credits} credits` : "Standard Pack"}
                    </div>
                  </div>
                  <div className="mt-3 flex items-center justify-between">
                    <div className="text-xs text-slate-500">Status: {achieved ? "Completed" : "In progress"}</div>
                    {achieved && !claimed && (
                      <button
                        onClick={() => onClaim(definition)}
                        className="rounded-full bg-emerald-500/70 px-3 py-1 text-xs uppercase tracking-[0.3em] text-emerald-50"
                      >
                        Claim
                      </button>
                    )}
                    {claimed && <span className="text-xs text-slate-500">Claimed</span>}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );

      const VerseDisplay = ({ show, verse }) => {
        if (!show) return null;
        return (
          <div className="mt-4 rounded-2xl border border-slate-600/40 bg-slate-900/60 p-4 text-sm font-serif text-slate-200">
            â{verse.text}â â {verse.ref} (KJV)
          </div>
        );
      };
      const SideGigsPanel = ({ usage, onLaunch }) => {
        const nowTime = now();
        return (
          <div className="glass rounded-3xl p-6">
            <div className="flex items-center justify-between">
              <h2 className="text-lg font-semibold text-slate-100">Side Gigs</h2>
              <span className="text-xs uppercase tracking-[0.3em] text-slate-500">Mini-games</span>
            </div>
            <div className="mt-4 space-y-3">
              {CONFIG.MINI_GAMES.map((game) => {
                const record = usage[game.id] || { history: [] };
                const perHour = record.history.filter((stamp) => nowTime - stamp < 3600000).length;
                const perDay = record.history.filter((stamp) => nowTime - stamp < 86400000).length;
                const exhausted = game.disabled || perHour >= CONFIG.MINI_GAME_LIMITS.perHour || perDay >= CONFIG.MINI_GAME_LIMITS.perDay;
                return (
                  <div key={game.id} className="rounded-2xl border border-slate-700/40 bg-slate-900/40 p-4">
                    <div className="flex items-center justify-between">
                      <div>
                        <div className="text-sm font-semibold text-slate-100">{game.name}</div>
                        <div className="text-xs text-slate-400">{game.description}</div>
                      </div>
                      <div className="text-xs text-slate-500">
                        {perHour}/{CONFIG.MINI_GAME_LIMITS.perHour} this hour Â· {perDay}/{CONFIG.MINI_GAME_LIMITS.perDay} today
                      </div>
                    </div>
                    <button
                      disabled={exhausted}
                      onClick={() => onLaunch(game)}
                      className={`mt-3 rounded-full px-3 py-1 text-xs uppercase tracking-[0.3em] ${
                        exhausted ? "bg-slate-800 text-slate-600" : "bg-indigo-500/80 text-indigo-50 hover:bg-indigo-400"
                      }`}
                    >
                      {game.disabled ? "In Development" : exhausted ? "Rest Required" : "Enter Gig"}
                    </button>
                  </div>
                );
              })}
            </div>
          </div>
        );
      };
      const ToastStack = ({ toasts, onDismiss }) => (
        <div className="pointer-events-none fixed bottom-6 left-1/2 z-50 flex w-full max-w-md -translate-x-1/2 flex-col gap-3">
          {toasts.map((toast) => (
            <div key={toast.id} className="toast-enter pointer-events-auto rounded-2xl bg-slate-900/90 px-4 py-3 text-sm text-slate-100 shadow-xl ring-1 ring-slate-700/50">
              <div className="flex items-center justify-between">
                <span>{toast.message}</span>
                <button onClick={() => onDismiss(toast.id)} className="text-xs uppercase tracking-[0.3em] text-slate-400">
                  Close
                </button>
              </div>
            </div>
          ))}
        </div>
      );
      const SettingsModal = ({ settings, onToggleVerse, onVolumeChange, onClose }) => (
        <div className="fixed inset-0 z-40 flex items-center justify-center bg-slate-950/80 backdrop-blur">
          <div className="glass w-full max-w-lg rounded-3xl p-8">
            <div className="flex items-start justify-between">
              <div>
                <h2 className="text-lg font-semibold text-slate-100">Settings</h2>
                <p className="text-xs text-slate-400">Dial the ambience and verse display.</p>
              </div>
              <button onClick={onClose} className="text-xs uppercase tracking-[0.3em] text-slate-400">
                Close
              </button>
            </div>
            <div className="mt-6 space-y-6">
              <label className="flex items-center justify-between text-sm text-slate-200">
                <span>Show KJV verse overlay</span>
                <input type="checkbox" checked={settings.showKJV} onChange={(event) => onToggleVerse(event.target.checked)} />
              </label>
              <div>
                <div className="text-sm text-slate-200">Ambient volume</div>
                <input
                  type="range"
                  min="0"
                  max="1"
                  step="0.05"
                  value={settings.volume}
                  onChange={(event) => onVolumeChange(parseFloat(event.target.value))}
                  className="mt-2 w-full"
                />
              </div>
            </div>
          </div>
        </div>
      );
      const MiniGameModal = ({ game, onComplete, onClose }) => {
        const canvasRef = useRef(null);
        const [uiState, setUiState] = useState({ time: CONFIG.MINI_GAME_LIMITS.durationSeconds, score: 0, detail: "" });
        useEffect(() => {
          if (!game || game.disabled) return;
          const canvas = canvasRef.current;
          const ctx = canvas.getContext("2d");
          canvas.width = 500;
          canvas.height = 320;
          const duration = CONFIG.MINI_GAME_LIMITS.durationSeconds;
          const start = performance.now();
          let running = true;
          const state = { score: 0, streak: 0, taps: [], beatIndex: 0, lane: 1, obstacles: [], pointer: 0, direction: 1 };

          const beatTimes = Array.from({ length: duration }, (_, i) => i + 1);

          const handleTap = () => {
            if (game.id === "timberline") {
              const currentTime = (performance.now() - start) / 1000;
              const nextBeat = beatTimes[state.beatIndex] || duration;
              const delta = Math.abs(currentTime - nextBeat);
              if (delta < 0.2) {
                state.streak += 1;
                state.score += 12 + state.streak * 2;
                state.detail = "On beat";
                state.beatIndex += 1;
              } else if (delta < 0.4) {
                state.streak = Math.max(0, state.streak - 1);
                state.score += 6;
                state.detail = "Close";
                state.beatIndex += 1;
              } else {
                state.streak = 0;
                state.detail = "Miss";
              }
            } else if (game.id === "riverside") {
              const closeness = 1 - Math.abs(state.pointer - 0.5) * 2;
              const haul = Math.max(0, closeness);
              state.score += Math.round(haul * 35 + Math.random() * 20);
              state.detail = haul > 0.75 ? "Golden catch" : haul > 0.4 ? "Solid pull" : "Light nibble";
            }
          };

          const keyHandler = (event) => {
            if (game.id === "courier") {
              if (event.key === "ArrowLeft" || event.key === "a") {
                state.lane = Math.max(0, state.lane - 1);
              } else if (event.key === "ArrowRight" || event.key === "d") {
                state.lane = Math.min(2, state.lane + 1);
              }
            }
            if (event.key === " " || event.key === "Enter") {
              handleTap();
            }
          };

          const pointerHandler = () => handleTap();

          window.addEventListener("keydown", keyHandler);
          canvas.addEventListener("pointerdown", pointerHandler);

          const spawnObstacle = () => {
            const lane = Math.floor(Math.random() * 3);
            state.obstacles.push({ lane, y: -40 });
          };
          let obstacleTimer = 0;

          const loop = (timestamp) => {
            if (!running) return;
            const elapsed = (timestamp - start) / 1000;
            const remaining = Math.max(0, duration - elapsed);
            if (game.id === "riverside") {
              state.pointer += state.direction * 0.008 * (1 + elapsed * 0.02);
              if (state.pointer <= 0) {
                state.pointer = 0;
                state.direction = 1;
              } else if (state.pointer >= 1) {
                state.pointer = 1;
                state.direction = -1;
              }
            }
            if (game.id === "courier") {
              obstacleTimer += 16;
              if (obstacleTimer > 700) {
                obstacleTimer = 0;
                spawnObstacle();
              }
              state.obstacles.forEach((obstacle) => {
                obstacle.y += 2.6 + elapsed * 0.01;
              });
              state.obstacles = state.obstacles.filter((obstacle) => obstacle.y < canvas.height + 40);
              state.score += 0.6;
              const collision = state.obstacles.find((obstacle) => obstacle.lane === state.lane && obstacle.y > 220 && obstacle.y < 260);
              if (collision) {
                state.score = Math.max(0, state.score - 40);
                state.detail = "Glancing hit";
                obstacle.y = canvas.height + 50;
              }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#0f172a";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (game.id === "timberline") {
              ctx.strokeStyle = "#334155";
              ctx.lineWidth = 6;
              ctx.beginPath();
              ctx.arc(canvas.width / 2, canvas.height / 2, 90, 0, Math.PI * 2);
              ctx.stroke();
              ctx.fillStyle = "#38bdf8";
              const beatProgress = (elapsed % 1);
              ctx.beginPath();
              ctx.arc(canvas.width / 2, canvas.height / 2, 90, -Math.PI / 2, -Math.PI / 2 + beatProgress * Math.PI * 2);
              ctx.stroke();
              ctx.fillStyle = "#fcd34d";
              ctx.beginPath();
              ctx.arc(canvas.width / 2, canvas.height / 2, 10 + 20 * (1 - beatProgress), 0, Math.PI * 2);
              ctx.fill();
            } else if (game.id === "riverside") {
              ctx.fillStyle = "#1e293b";
              ctx.fillRect(60, 120, canvas.width - 120, 80);
              ctx.fillStyle = "#0ea5e9";
              ctx.fillRect(60, 150, canvas.width - 120, 20);
              ctx.fillStyle = "#fcd34d";
              const pointerX = 60 + state.pointer * (canvas.width - 120);
              ctx.fillRect(pointerX - 6, 110, 12, 100);
              ctx.fillStyle = "rgba(148, 163, 184, 0.3)";
              ctx.fillRect(canvas.width / 2 - 20, 120, 40, 80);
            } else if (game.id === "courier") {
              ctx.fillStyle = "#1e293b";
              ctx.fillRect(140, 40, 220, 240);
              ctx.strokeStyle = "#334155";
              ctx.beginPath();
              ctx.moveTo(213, 40);
              ctx.lineTo(213, 280);
              ctx.moveTo(287, 40);
              ctx.lineTo(287, 280);
              ctx.stroke();
              ctx.fillStyle = "#38bdf8";
              const laneX = [170, 244, 318][state.lane];
              ctx.fillRect(laneX - 20, 220, 40, 40);
              ctx.fillStyle = "#f87171";
              state.obstacles.forEach((obstacle) => {
                const ox = [170, 244, 318][obstacle.lane];
                ctx.fillRect(ox - 18, obstacle.y, 36, 36);
              });
            }

            setUiState({ time: remaining, score: state.score, detail: state.detail || "" });

            if (remaining <= 0) {
              running = false;
              const normalized = Math.min(1, state.score / 300);
              const reward = Math.round(lerp(game.minReward, game.maxReward, normalized));
              window.removeEventListener("keydown", keyHandler);
              canvas.removeEventListener("pointerdown", pointerHandler);
              onComplete({ reward, score: Math.round(state.score) });
              return;
            }
            requestAnimationFrame(loop);
          };
          requestAnimationFrame(loop);
          return () => {
            running = false;
            window.removeEventListener("keydown", keyHandler);
            canvas.removeEventListener("pointerdown", pointerHandler);
          };
        }, [game]);

        if (!game) return null;
        return (
          <div className="mini-game-overlay fixed inset-0 z-50 flex items-center justify-center bg-slate-950/80 backdrop-blur">
            <div className="glass w-full max-w-3xl rounded-3xl p-8">
              <div className="flex items-center justify-between">
                <div>
                  <h2 className="text-lg font-semibold text-slate-100">{game.name}</h2>
                  <p className="text-xs text-slate-400">{game.description}</p>
                </div>
                <button onClick={onClose} className="text-xs uppercase tracking-[0.3em] text-slate-400">
                  Exit
                </button>
              </div>
              <div className="mt-6 flex flex-col items-center gap-4">
                <canvas ref={canvasRef} className="bg-slate-950" width="500" height="320"></canvas>
                <div className="flex w-full justify-between text-sm text-slate-300">
                  <span>Time: {Math.ceil(uiState.time)}s</span>
                  <span>Score: {Math.round(uiState.score)}</span>
                  <span>{uiState.detail}</span>
                </div>
                <div className="text-xs text-slate-500">Tap / Space for Rhythm & Fishing Â· Arrow keys for Courier</div>
              </div>
            </div>
          </div>
        );
      };
      const applyOfflineProgress = (state) => {
        const current = now();
        const elapsedMs = current - (state.lastTick || current);
        if (elapsedMs <= 0) return state;
        const minutes = elapsedMs / 60000;
        const statDecay = state.contract && state.contract.endsAt && state.contract.endsAt > state.lastTick
          ? CONFIG.STAT_DECAY_CONTRACT_PER_MIN
          : CONFIG.STAT_DECAY_IDLE_PER_MIN;
        const moraleCap = moraleMax(state.decor);
        const adjustStat = (value, cap) => {
          const factor = value >= CONFIG.STAT_DECAY_THRESHOLD ? CONFIG.STAT_DECAY_REDUCTION_FACTOR : 1;
          const newValue = value + statDecay * minutes * factor;
          return clamp(newValue, CONFIG.STAT_MIN, cap);
        };
        state.stats.energy = adjustStat(state.stats.energy, CONFIG.BASE_STAT_MAX);
        state.stats.cleanliness = adjustStat(state.stats.cleanliness, CONFIG.BASE_STAT_MAX);
        state.stats.morale = adjustStat(state.stats.morale, moraleCap);

        let contract = state.contract;
        if (contract && contract.endsAt <= current) {
          state.credits += contract.payout;
          state.lifetime.creditsEarned += contract.payout;
          state.lifetime.contractsCompleted += 1;
          state.toast.push({ id: `contract-${contract.id}-${current}`, message: `${contract.label} complete Â· +${contract.payout} credits` });
          contract = null;
        }
        state.contract = contract;

        const allHealthy = state.stats.energy >= 70 && state.stats.cleanliness >= 70 && state.stats.morale >= 70;
        if (allHealthy) {
          state.lifetime.moraleAbove70Minutes += minutes;
        }

        const onDuty = state.stats.energy >= 60 && state.stats.cleanliness >= 60 && state.stats.morale >= 60;
        if (onDuty) {
          const rarityData = CONFIG.RARITIES[state.rarity] || CONFIG.RARITIES.Common;
          let rate = 2 * rarityData.multiplier; // per minute
          if (state.stats.energy < 40 || state.stats.cleanliness < 40 || state.stats.morale < 40) {
            rate *= 0.75;
          }
          const earned = rate * minutes;
          state.credits += earned;
          state.lifetime.creditsEarned += earned;
          state.lifetime.dutyMinutes += minutes;
        }
        state.lastTick = current;
        state.milestones = updateMilestones(state);
        return state;
      };
      const updateMilestones = (state) => {
        return state.milestones.map((entry) => {
          const definition = CONFIG.MILESTONES.find((m) => m.id === entry.id);
          if (!definition) return entry;
          if (entry.achieved) return entry;
          let achieved = entry.achieved;
          if (entry.id === "professional-i") {
            achieved = state.lifetime.moraleAbove70Minutes >= 180;
          } else if (entry.id === "craftsman") {
            achieved = state.lifetime.contractsCompleted >= 5 && state.stats.morale >= 50;
          } else if (entry.id === "steady-hand") {
            achieved = state.lifetime.creditsEarned >= 10000;
          }
          return { ...entry, achieved };
        });
      };
      const App = () => {
        const [state, setState] = useState(() => applyOfflineProgress(loadState()));
        const [packResults, setPackResults] = useState(null);
        const [showWardrobe, setShowWardrobe] = useState(false);
        const [showSettings, setShowSettings] = useState(false);
        const [activeMiniGame, setActiveMiniGame] = useState(null);
        const [dragPreview, setDragPreview] = useState(null);
        const canvasRef = useRef(null);
        const roomRef = useRef(null);
        const busRef = useRef(new EventBus());
        const stateRef = useRef(state);
        const packEngineRef = useRef(null);
        const audioContextRef = useRef(null);
        const gainRef = useRef(null);

        useEffect(() => {
          stateRef.current = state;
          saveState(state);
          mirrorToFirebase(state);
        }, [state]);

        useEffect(() => {
          if (!canvasRef.current) return;
          roomRef.current = new RoomEngine(canvasRef.current, busRef.current);
          return () => {
            if (roomRef.current) roomRef.current.running = false;
          };
        }, []);

        useEffect(() => {
          if (roomRef.current) {
            roomRef.current.setDecor(state.decor);
          }
        }, [state.decor]);

        const equippedForRoom = useMemo(() => {
          const payload = {};
          Object.entries(state.accessories.equipped).forEach(([slot, item]) => {
            if (item) payload[slot] = item;
          });
          return payload;
        }, [state.accessories.equipped]);

        useEffect(() => {
          if (roomRef.current) {
            roomRef.current.setAccessories(equippedForRoom);
          }
        }, [equippedForRoom]);

        useEffect(() => {
          packEngineRef.current = new PackEngine(stateRef, (newState) => setState({ ...newState }));
        }, []);

        const dragItemRef = useRef(null);

        useEffect(() => {
          const handlePointer = (point) => {
            setDragPreview((prev) => (prev ? { ...prev, point } : prev));
          };
          const handleLeave = () => {
            setDragPreview((prev) => (prev ? { ...prev, point: null } : prev));
          };
          const handleDrop = (tile) => {
            if (!dragItemRef.current) return;
            placeDecorAt(tile, dragItemRef.current);
            dragItemRef.current = null;
            setDragPreview(null);
          };
          const bus = busRef.current;
          bus.on("room-pointer", handlePointer);
          bus.on("room-pointer-leave", handleLeave);
          bus.on("room-pointer-up", handleDrop);
          return () => {
            bus.off("room-pointer", handlePointer);
            bus.off("room-pointer-leave", handleLeave);
            bus.off("room-pointer-up", handleDrop);
          };
        }, []);

        const placeDecorAt = (tile, item) => {
          setState((prev) => {
            if (item.isNew && prev.credits < item.value) {
              return prev;
            }
            const existing = prev.decor.filter((decor) => decor.uid !== item.uid);
            const updated = [
              ...existing,
              {
                uid: item.uid,
                id: item.id,
                name: item.name,
                tint: item.tint,
                moraleCap: item.moraleCap,
                value: item.value,
                col: tile.col,
                row: tile.row,
              },
            ];
            return {
              ...prev,
              credits: item.isNew ? prev.credits - item.value : prev.credits,
              decor: updated,
            };
          });
        };

        const beginDecorDrag = (item) => {
          dragItemRef.current = item;
          setDragPreview({ ...item, point: null });
        };

        const moveDecor = (item) => {
          dragItemRef.current = { ...item, isNew: false };
          setDragPreview({ ...item, point: null });
          setState((prev) => ({ ...prev, decor: prev.decor.filter((decor) => decor.uid !== item.uid) }));
        };

        const sellDecor = (item) => {
          setState((prev) => {
            const updated = prev.decor.filter((decor) => decor.uid !== item.uid);
            return { ...prev, decor: updated, credits: prev.credits + Math.floor(item.value * 0.6) };
          });
        };

        const handleQuickCare = () => {
          setState((prev) => {
            if (prev.credits < CONFIG.QUICK_CARE_COST) return prev;
            const moraleCap = moraleMax(prev.decor);
            return {
              ...prev,
              credits: prev.credits - CONFIG.QUICK_CARE_COST,
              stats: {
                energy: clamp(prev.stats.energy + CONFIG.QUICK_CARE_BOOST, CONFIG.STAT_MIN, CONFIG.BASE_STAT_MAX),
                cleanliness: clamp(prev.stats.cleanliness + CONFIG.QUICK_CARE_BOOST, CONFIG.STAT_MIN, CONFIG.BASE_STAT_MAX),
                morale: clamp(prev.stats.morale + CONFIG.QUICK_CARE_BOOST, CONFIG.STAT_MIN, moraleCap),
              },
            };
          });
        };

        const handleContractStart = (job) => {
          setState((prev) => {
            if (prev.contract) return prev;
            const moraleCap = moraleMax(prev.decor);
            return {
              ...prev,
              contract: {
                ...job,
                startedAt: now(),
                endsAt: now() + job.durationMinutes * 60000,
              },
              stats: {
                ...prev.stats,
                energy: clamp(prev.stats.energy - job.energyCost, CONFIG.STAT_MIN, CONFIG.BASE_STAT_MAX),
              },
            };
          });
        };

        const handleContractCancel = () => {
          setState((prev) => ({ ...prev, contract: null }));
        };

        const handlePackOpen = (key) => {
          const engine = packEngineRef.current;
          if (!engine) return;
          const results = engine.openPack(key);
          if (results.length) {
            setPackResults(results);
          }
        };

        const handleEquip = (slot, item) => {
          setState((prev) => ({
            ...prev,
            accessories: {
              ...prev.accessories,
              equipped: { ...prev.accessories.equipped, [slot]: item },
            },
          }));
        };

        const handleMilestoneClaim = (definition) => {
          setState((prev) => {
            const milestones = prev.milestones.map((entry) =>
              entry.id === definition.id ? { ...entry, claimed: true } : entry
            );
            const updates = { ...prev, milestones };
            if (definition.reward.credits) {
              updates.credits += definition.reward.credits;
            } else if (definition.reward.pack) {
              const packKey = definition.reward.pack;
              updates.packs = { ...prev.packs, [packKey]: (prev.packs[packKey] || 0) + 1 };
            }
            return updates;
          });
        };

        const dismissToast = (id) => {
          setState((prev) => ({ ...prev, toast: prev.toast.filter((toast) => toast.id !== id) }));
        };

        useEffect(() => {
          if (!state.toast.length) return;
          const timer = setTimeout(() => {
            setState((prev) => ({ ...prev, toast: prev.toast.slice(1) }));
          }, 4800);
          return () => clearTimeout(timer);
        }, [state.toast]);

        useEffect(() => {
          const timer = setInterval(() => {
            setState((prev) => {
              const moraleCap = moraleMax(prev.decor);
              const baseDecay = prev.contract ? CONFIG.STAT_DECAY_CONTRACT_PER_MIN : CONFIG.STAT_DECAY_IDLE_PER_MIN;
              const decayStep = baseDecay / 60; // per minute to per second
              const applyDecay = (value, cap) => {
                const factor = value >= CONFIG.STAT_DECAY_THRESHOLD ? CONFIG.STAT_DECAY_REDUCTION_FACTOR : 1;
                return clamp(value + decayStep * factor, CONFIG.STAT_MIN, cap);
              };
              const stats = {
                energy: applyDecay(prev.stats.energy, CONFIG.BASE_STAT_MAX),
                cleanliness: applyDecay(prev.stats.cleanliness, CONFIG.BASE_STAT_MAX),
                morale: applyDecay(prev.stats.morale, moraleCap),
              };
              const rarityData = CONFIG.RARITIES[prev.rarity] || CONFIG.RARITIES.Common;
              let credits = prev.credits;
              let dutyMinutes = prev.lifetime.dutyMinutes;
              let creditsEarned = prev.lifetime.creditsEarned;
              if (stats.energy >= 60 && stats.cleanliness >= 60 && stats.morale >= 60) {
                let perMinute = 2 * rarityData.multiplier;
                if (stats.energy < 40 || stats.cleanliness < 40 || stats.morale < 40) perMinute *= 0.75;
                const perSecond = perMinute / 60;
                credits += perSecond;
                creditsEarned += perSecond;
                dutyMinutes += 1 / 60;
              }
              const lifetime = {
                ...prev.lifetime,
                creditsEarned,
                dutyMinutes,
                moraleAbove70Minutes:
                  stats.energy >= 70 && stats.cleanliness >= 70 && stats.morale >= 70
                    ? prev.lifetime.moraleAbove70Minutes + 1 / 60
                    : prev.lifetime.moraleAbove70Minutes,
                contractsCompleted: prev.lifetime.contractsCompleted,
              };
              const contract = prev.contract && prev.contract.endsAt <= now() ? null : prev.contract;
              const toast = [...prev.toast];
              if (prev.contract && prev.contract.endsAt <= now()) {
                credits += prev.contract.payout;
                creditsEarned += prev.contract.payout;
                lifetime.creditsEarned = creditsEarned;
                lifetime.contractsCompleted = prev.lifetime.contractsCompleted + 1;
                toast.push({ id: `contract-${prev.contract.id}-${now()}`, message: `${prev.contract.label} complete Â· +${prev.contract.payout} credits` });
              }
              const milestones = updateMilestones({ ...prev, stats, lifetime });
              return { ...prev, stats, credits, lifetime, contract, toast, milestones, lastTick: now() };
            });
          }, 1000);
          return () => clearInterval(timer);
        }, []);

        useEffect(() => {
          if (state.settings.volume <= 0) return;
          if (!audioContextRef.current) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return;
            const context = new AudioContext();
            const gain = context.createGain();
            const oscillator = context.createOscillator();
            oscillator.type = "sine";
            oscillator.frequency.value = 92;
            const lfo = context.createOscillator();
            lfo.type = "sine";
            lfo.frequency.value = 0.1;
            const lfoGain = context.createGain();
            lfoGain.gain.value = 30;
            lfo.connect(lfoGain).connect(oscillator.frequency);
            gain.gain.value = state.settings.volume * 0.08;
            oscillator.connect(gain).connect(context.destination);
            oscillator.start();
            lfo.start();
            audioContextRef.current = context;
            gainRef.current = gain;
            const resume = () => {
              if (context.state === "suspended") context.resume();
            };
            window.addEventListener("pointerdown", resume, { once: true });
          } else if (gainRef.current) {
            gainRef.current.gain.value = state.settings.volume * 0.08;
          }
        }, [state.settings.volume]);

        const handleMiniGameLaunch = (game) => {
          if (game.disabled) return;
          const usage = state.miniGameUsage[game.id] || { history: [] };
          const recent = usage.history || [];
          const perHour = recent.filter((stamp) => now() - stamp < 3600000).length;
          const perDay = recent.filter((stamp) => now() - stamp < 86400000).length;
          if (perHour >= CONFIG.MINI_GAME_LIMITS.perHour || perDay >= CONFIG.MINI_GAME_LIMITS.perDay) {
            setState((prev) => ({
              ...prev,
              toast: [
                ...prev.toast,
                {
                  id: `gig-limit-${game.id}-${now()}`,
                  message: `${game.name} Â· rest before the next attempt`,
                },
              ],
            }));
            return;
          }
          setActiveMiniGame(game);
        };

        const handleMiniGameComplete = ({ reward, score }) => {
          const completedGame = activeMiniGame;
          setActiveMiniGame(null);
          setState((prev) => {
            if (!completedGame) return prev;
            const usage = { ...prev.miniGameUsage };
            const history = usage[completedGame.id]?.history || [];
            const updatedHistory = [...history.filter((stamp) => now() - stamp < 86400000), now()];
            usage[completedGame.id] = { history: updatedHistory };
            const toast = [...prev.toast, { id: `gig-${completedGame.id}-${now()}`, message: `${completedGame.name} Â· ${Math.round(score)} pts Â· +${reward} credits` }];
            return {
              ...prev,
              credits: prev.credits + reward,
              lifetime: { ...prev.lifetime, creditsEarned: prev.lifetime.creditsEarned + reward },
              miniGameUsage: usage,
              toast,
            };
          });
        };

        const toggleVerse = (value) => {
          setState((prev) => ({
            ...prev,
            settings: { ...prev.settings, showKJV: value },
            verseIndex: value ? (prev.verseIndex + 1) % CONFIG.KJV_VERSES.length : prev.verseIndex,
          }));
        };

        const handleVolume = (value) => {
          setState((prev) => ({ ...prev, settings: { ...prev.settings, volume: value } }));
        };

        const verse = CONFIG.KJV_VERSES[state.verseIndex % CONFIG.KJV_VERSES.length];

        const activeContract = state.contract;

        return (
          <div className="mx-auto flex min-h-screen max-w-7xl flex-col gap-8 px-6 py-10">
            <header className="flex flex-wrap items-center justify-between gap-4">
              <div>
                <h1 className="text-3xl font-semibold text-slate-100">Team Bear Â· Studio Loop</h1>
                <p className="text-sm text-slate-400">Maintain a composed bear, manage credits, and unlock composed milestones.</p>
              </div>
              <div className="flex items-center gap-3">
                <button
                  onClick={() => setShowWardrobe(true)}
                  className="rounded-full border border-slate-600/40 px-4 py-2 text-xs uppercase tracking-[0.3em] text-slate-200 hover:border-slate-400"
                >
                  Wardrobe
                </button>
                <button
                  onClick={() => setShowSettings(true)}
                  className="rounded-full border border-slate-600/40 px-4 py-2 text-xs uppercase tracking-[0.3em] text-slate-200 hover:border-slate-400"
                >
                  Settings
                </button>
              </div>
            </header>

            <main className="grid grid-cols-1 gap-8 lg:grid-cols-[2fr,1fr]">
              <div className="glass relative rounded-3xl p-6">
                <div className="overflow-hidden rounded-3xl border border-slate-600/30 bg-slate-950/60 p-4">
                  <div className="mx-auto w-[768px] max-w-full">
                    <div className="relative" style={{ padding: `${CONFIG.ROOM_PADDING}px` }}>
                      <canvas ref={canvasRef} className="room-grid-shadow w-full" style={{ aspectRatio: `${CONFIG.GRID.COLS} / ${CONFIG.GRID.ROWS}` }}></canvas>
                      <DecorOverlay decor={state.decor} onMove={moveDecor} onSell={sellDecor} />
                      {dragPreview && dragPreview.point && (
                        <div
                          className="pointer-events-none absolute h-16 w-16 -translate-x-1/2 -translate-y-1/2 rounded-full border border-emerald-400/60 bg-emerald-400/20"
                          style={{ left: dragPreview.point.x, top: dragPreview.point.y }}
                        ></div>
                      )}
                    </div>
                  </div>
                </div>
                <VerseDisplay show={state.settings.showKJV} verse={verse} />
              </div>
              <div className="space-y-6">
                <StatsPanel stats={state.stats} decor={state.decor} onQuickCare={handleQuickCare} canAfford={state.credits >= CONFIG.QUICK_CARE_COST} />
                <CurrencyPanel credits={state.credits} vouchers={state.vouchers} />
                <ContractPanel contract={activeContract} onStart={handleContractStart} onCancel={handleContractCancel} />
              </div>
            </main>

            <section className="grid grid-cols-1 gap-8 lg:grid-cols-3">
              <DecorCatalog onBeginDrag={beginDecorDrag} />
              <SideGigsPanel usage={state.miniGameUsage} onLaunch={handleMiniGameLaunch} />
              <MilestonesPanel milestones={state.milestones} definitions={CONFIG.MILESTONES} onClaim={handleMilestoneClaim} />
            </section>

            <section className="glass rounded-3xl p-6">
              <h2 className="text-lg font-semibold text-slate-100">Packs</h2>
              <div className="mt-4 grid grid-cols-1 gap-4 md:grid-cols-3">
                {Object.entries(CONFIG.PACK_TYPES).map(([key, pack]) => (
                  <PackButton key={key} pack={pack} onOpen={() => handlePackOpen(key)} />
                ))}
              </div>
            </section>

            {packResults && <PackReveal results={packResults} onClose={() => setPackResults(null)} />}
            {showWardrobe && (
              <WardrobeModal
                inventory={state.accessories.inventory}
                equipped={state.accessories.equipped}
                onClose={() => setShowWardrobe(false)}
                onEquip={handleEquip}
              />
            )}
            {showSettings && (
              <SettingsModal
                settings={state.settings}
                onToggleVerse={toggleVerse}
                onVolumeChange={handleVolume}
                onClose={() => setShowSettings(false)}
              />
            )}
            {activeMiniGame && (
              <MiniGameModal
                game={activeMiniGame}
                onComplete={handleMiniGameComplete}
                onClose={() => setActiveMiniGame(null)}
              />
            )}
            <ToastStack toasts={state.toast} onDismiss={dismissToast} />
          </div>
        );
      };

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
